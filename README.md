# Sylvia Framework

Sylvia, named after the Spirit of the Wood and the Roman goddess of the forest, is more than a mythological figure.

It's a robust framework designed to streamline your journey into the CosmWasm smart contracts world. Sylvia offers an abstraction-focused and scalable solution, allowing you to delve into the Cosmos ecosystem with ease. 

Our toolset ensures that instead of getting entangled in the raw structure of your contracts, you focus on crafting them in idiomatic Rust, letting Cargo handle the rest.

Discover more about `sylvia` in [the book](https://cosmwasm.github.io/sylvia-book/index.html)

## The Approach

The [CosmWasm](https://cosmwasm.com/) ecosystem lays the foundational blocks for smart contracts:
[cosmwasm-std](https://crates.io/crates/cosmwasm-std) for essential CW bindings, [cw-storage-plus](https://crates.io/crates/cw-storage-plus) for simplified state management, and [cw-multi-test](https://crates.io/crates/cw-multi-test) for effiecient testing. Built atop these, the Sylvia framework liberates you from the intricacies of the message structures, , API serialization, and message dispatching. Your contract's API becomes a suite of traits implemented on your SC type, while Sylvia seamlessly generates entry point structures and message dispatching functions, alongside multi-test helpers for an enhanced development experience.

## Code Generation

From its initial proof of concept, `Sylvia` has evolved to generate an array of utilities, streamlining the development process. 

Starting with version `0.9.0`, all code generated by `Sylvia` is neatly organized in the `sv` module, providing a structured and intuitive coding environment.

## Using Sylvia in Contracts

Begin with your contract crate, which should be a library crate:

```shell
$ cargo new --lib ./my-crate
     Created library `./my-crate` package

```

To integrate Sylvia into your contract, add dependencies for Sylvia, `serde`, `cosmwasm-schema`, `schemars`, and `cosmwasm_std`:

```shell
$ cargo add sylvia cosmwasm-schema schemars cosmwasm-std serde
...
```

Ensure your crate compiles as `cdylib`, setting the appropriate crate type in `Cargo.toml`. Adding `rlib` allows using the contract as a dependency. Example `Cargo.toml`:

```toml
[package]
name = "my-crate"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[dependencies]
cosmwasm-schema = "1.2.5"
cosmwasm-std = "1.2.5"
schemars = "0.8.12"
serde = "1.0.160"
sylvia = "0.5.0"
```

To build your contract as wasm you can use:

```rust
$ cargo build --target wasm32-unknown-unknown
...
```

## Contract Type

In Sylvia, we define our contracts using Rust structures:

For a more detailed look into contract instantiation:

```rust
pub struct MyContract;
```

The next step is to create an instantiation message for the contract we have:

```rust
use sylvia::contract;
use sylvia::types::InstantiateCtx;
use sylvia::cw_std::{StdResult, Response};

#[contract]
impl MyContract {
    #[msg(instantiate)]
    pub fn instantiate(&self, _ctx: InstantiateCtx) -> StdResult<Response> {
        Ok(Response::new())
    }
}
```
The code snippet automatically creates an `InstantiateMessage` type in your module. It initally has no fields but will evolve as your contract's needs grow.

```rust
struct InstantiateMsg {}
```
To create a contract instantiate entry point for CosmWasm, use the `entry_point` macro:

```rust
use sylvia::{contract, entry_points;
use sylvia::types::InstantiateCtx;
use sylvia::cw_std::{StdResult, Response};

#[entry_points]
#[contract]
impl MyContract {
    #[msg(instantiate)]
    pub fn instantiate(&self, _ctx: InstantiateCtx) -> StdResult<Response> {
        Ok(Response::new())
    }
}
```

This will generate for us `instantiate`, `execute` and `query` entry points.
Inside they will call `dispatch` on the msg received and run proper logic defined for the sent
variant of the message.

```rust
pub mod entry_points {
    use super::*;

    #[sylvia::cw_std::entry_point]
    pub fn instantiate(
        deps: sylvia::cw_std::DepsMut,
        env: sylvia::cw_std::Env,
        info: sylvia::cw_std::MessageInfo,
        msg: InstantiateMsg,
    ) -> Result<sylvia::cw_std::Response, StdError> {
        msg.dispatch(&MyContract::new(), (deps, env, info))
            .map_err(Into::into)
    }
```

Now we would like to do something useful in the contract instantiation. Let's
start using the [cw-storage-plus](https://docs.rs/cw-storage-plus/1.0.1/cw_storage_plus/)
to add state to the contract (remember to add it as dependency):

```rust
use cw_storage_plus::Item;

struct MyContract<'a> {
    pub counter: Item<'a, u64>,
}

#[entry_points]
#[contract]
impl MyContract<'_> {
    pub fn new() -> Self {
        Self {
            counter: Item::new("counter")
        }
    }

    #[msg(instantiate)]
    pub fn instantiate(&self, ctx: InstantiateCtx) -> StdResult<Response> {
        self.counter.save(ctx.deps.storage, &0)?;

        Ok(Response::new())
    }
}
```

We need to add this generic lifetime because of an optimization in storage plus -
it doesn't want to take an owned string, as we often pass there a static string,
but it also doesn't want to fix the `'static` ownership. 99% of the time, you can
get away with passing just `'static` as the first `Item` generic argument, but I
find it more convenient to introduce this "proxy" lifetime passing everywhere. I
eliminate it in the `new` constructor, where I create the storage-plus accessors
giving them proper keys.

Now let's pass the initial counter state as a function argument:

```rust
#[contract]
impl MyContract<'_> {
    #[msg(instantiate)]
    pub fn instantiate(&self, ctx: InstantiateCtx, counter: u64) -> StdResult<Response> {
        self.counter.save(ctx.deps.storage, &counter)?;

        Ok(Response::new())
    }
}
```

Sylvia would add the field into the instantiation message, which now becomes this:

```rust
struct InstantiateMsg {
    counter: u64,
}
```

What is essential - the field in the `InstantiateMsg` gets the same name as the
function argument.

Now let's add an execution message to the contract:

```rust
#[contract]
impl MyContract<'_> {
    #[msg(exec)]
    pub fn increment(&self, ctx: ExecCtx) -> StdResult<Response> {
        let counter = self.counter.load(ctx.deps.storage)?;
        self.counter.save(ctx.deps.storage, &(counter + 1))?;
        Ok(Response::new())
    }
}
```

Sylvia generated two message types from this:

```rust
enum ExecMsg {
    Increment {}
}

enum ContractExecMsg {
    MyContract(ExecMsg)
}
```

The `ExecMsg` is the primary one you may use to send messages to the contract.
The `ContractExecMsg` is only an additional abstraction layer that would matter
later when we define traits for our contract.
Thanks to `entry_point` macro it is already being used in the generated entry point and we don't
have to do it manually.

One problem you might face now is that we use the `StdResult` for our contract,
but we often want to define the custom error type for our contracts - fortunately,
it is very easy to do:

```rust
use sylvia::cw_std::ensure;

#[contract]
#[error(ContractError)]
impl MyContract<'_> {
    #[msg(exec)]
    pub fn increment(&self, ctx: ExecCtx) -> Result<Response, ContractError> {
        let counter = self.counter.load(ctx.deps.storage)?;

        ensure!(counter < 10, ContractError::LimitReached);

        self.counter.save(ctx.deps.storage, &(counter + 1))?;
        Ok(Response::new())
    }
}
```

ContractError here is any error type you define for the contract - most typically
with the [thiserror](https://docs.rs/thiserror/1.0.40/thiserror/) crate.
The error type in an entry points will be updated automatically.

Finally, let's take a look at defining the query message:

```rust
use cosmwasm_schema::cw_serde;
use sylvia::types::QueryCtx;

#[cw_serde]
pub struct CounterResp {
    pub counter: u64,
}

#[contract]
#[error(ContractError)]
impl MyContract<'_> {
    #[msg(query)]
    pub fn counter(&self, ctx: QueryCtx) -> StdResult<CounterResp> {
        self
            .counter
            .load(ctx.deps.storage)
            .map(|counter| CounterResp { counter })
    }
}
```

What you might notice - we can still use `StdResult` (so `StdError`) if we don't
need `ContractError` in a particular function. What is important is that the returned
result type has to implement `Into<ContractError>`, where `ContractError` is a contract
error type - it will all be commonized in the generated dispatching function (so
entry points have to return `ContractError` as its error variant).

Messages equivalent to execution messages are generated.
Again entry point is already generated like in case of execute and instantiate.

## Interfaces

One of the fundamental ideas of Sylvia's framework are interfaces, allowing the
grouping of messages into their semantical groups. Let's define a Sylvia interface:

```rust
pub mod group {
    use super::*;
    use sylvia::interface;
    use sylvia::types::ExecCtx;
    use sylvia::cw_std::StdError;

    #[cw_serde]
    pub struct IsMemberResp {
        pub is_member: bool,
    }

    #[interface]
    pub trait Group {
        type Error: From<StdError>;

        #[msg(exec)]
        fn add_member(&self, ctx: ExecCtx, member: String) -> Result<Response, Self::Error>;

        #[msg(query)]
        fn is_member(&self, ctx: QueryCtx, member: String) -> Result<IsMemberResp, Self::Error>;
    }
}
```

Then we need to implement the trait on the contract type:

```rust
use sylvia::cw_std::{Empty, Addr};
use cw_storage_plus::{Map, Item};

pub struct MyContract<'a> {
    counter: Item<'a, u64>,
    // New field added - remember to initialize it in `new`
    members: Map<'a, &'a Addr, Empty>,
}

#[contract]
#[messages(group as Group)]
impl group::Group for MyContract<'_> {
    type Error = ContractError;

    #[msg(exec)]
    fn add_member(&self, ctx: ExecCtx, member: String) -> Result<Response, ContractError> {
        let member = ctx.deps.api.addr_validate(&member)?;
        self.members.save(ctx.deps.storage, &member, &Empty {})?;
        Ok(Response::new())
    }

    #[msg(query)]
    fn is_member(&self, ctx: QueryCtx, member: String) -> Result<group::IsMemberResp, ContractError> {
        let is_member = self.members.has(ctx.deps.storage, &Addr::unchecked(&member));
        let resp = group::IsMemberResp {
            is_member,
        };

        Ok(resp)
    }
}

#[contract]
#[messages(group as Group)]
impl MyContract<'_> {
    // Nothing changed here
}
```

Here are a couple of things to talk about.

First, note that I defined the interface trait in its separate module with a name
matching the trait name, but written "snake_case" instead of CamelCase. Here I have
`group` module for the `Group` trait, but the `CrossStaking` trait should be placed
in its own `cross_staking` module (note the underscore). This is a requirement right
now - Sylvia generates all the messages and boilerplate in this module and will try
to access them through this module.

Then there is the `Error` type embedded in the trait - it is also needed there,
and the trait bound here has to be at least `From<StdError>`, as Sylvia might
generate code returning an `StdError` in deserialization/dispatching implementation.
The trait can be more strict - this is the minimum.

Another thing to remember is that the `#[msg(...)]` attributes become part of the
function signature - they must be the same for the trait and later implementation.

Finally, every implementation block has an additional
`#[messages(module as Identifier)]` attribute. Sylvia needs it to generate the dispatching
properly - there is the limitation that every macro has access only to its local
scope. In particular - we cannot see all traits implemented by a type and their
implementation from the `#[contract]` crate.

To solve this issue, we put this `#[messages(...)]` attribute pointing to Sylvia
what is the module name where the interface is defined, and giving a unique name
for this interface (it would be used in generated code to provide proper enum variant).

The impl-block with trait implementation also contains the `#[messages]` attribute,
but only one - the one with info about the trait being implemented.

## Macro Attributes

`Sylvia` works with multiple attributes. I will explain here how and when to use which of them.

`Sylvia` utilizes several attributes to enhance its functionality:

```rust
#[contract(module=contract_module::inner_module)]
impl Interface for MyContract {
...
}
```

`module`: When implementing an interfce on the contract, use this to inform `Sylvia` where the contract is defined. If the contract implementation is in the same scope, this attribute can be omitted.

```rust
#[entry_point]
#[contract]
#[error(ContractError)]
impl MyContract {
...
}
```

`error`: Used by both `contract` and `entry_point` macros. Necessary fr defining a custom error type for your contract. If omitted, the default `StdError` is used.

```rust
#[contract]
#[messages(interface as Interface)]
impl MyContract {
...
}

#[contract]
#[messages(interface as Interface)]
impl Interface for MyContract {
...
}
```

`messages`: For the `contract` macro, indicating what interface is being implemented and its module name. Mandatory for interface functionality to be part of the contract logic.

In case of the implementation of a trait it is only needed if the trait is defined in different
module. Otherwise it should be omitted.
For the contract implementation it is mandatory for the functionality of an implemented trait
to be part of a contract logic.
For the interface implementation there should be at most one `messages` attribute used.
In case of the contract implementation there can be multiple `messages` attributes used.


`sv::override_entry_points`: Refer to the `Override Entry Point` section for details.

```rust
struct MyMsg;
impl CustomMsg for MyMsg {}

struct MyQuery;
impl CustomQuery for MyMsg {}

#[contract]
#[sv::custom(msg=MyMsg, query=MyQuery)]
impl MyContract {
...
}
```

`sv::custom` allows to define CustomMsg and CustomQuery for the contract. By default generated code
will return `Response<Empty>` and will use `Deps<Empty>` and `DepsMut<Empty>`.

`sv::custom`: Defines `CustomMsg` and `CustomQuery` for the contract. The default returns `Response<Empty>` and uses `Deps<Empty>`and `DepsMut<Empty>`.

## Single Module per Macro

To avoid overlapping of genrated items and namespaces, it's recommended to seperate macro calls into individual modules. This approach enhances project readability and preapres for potential future features additions.

## Usage in External Crates

Sylvia allows the usage of generated code in external projects. For example, to generate and view documentation:

```sh
cargo doc --document-private-items --open
```

This command generates comprehensive documentation, including all generated structures, and opens it for review. The 
`--document-private-item` flag is optional but useful for viewing non-public modules.

Use the generated messages directly to send them to the contract:

```rust
use sylvia::cw_std::{WasmMsg, to_json_binary};

fn some_handler(my_contract_addr: String) -> StdResult<Response> {
    let msg = my_contract_crate::ExecMsg::Increment {};
    let msg = WasmMsg::ExecMsg {
        contract_addr: my_contract_addr,
        msg: to_json_binary(&msg)?,
        funds: vec![],
    }

    let resp = Response::new()
        .add_message(msg);
    Ok(resp)
}
```

For queries:

```rust
let msg = my_contract_crate::group::QueryMsg::IsMember {
    member: addr,
};

let is_member: my_contract_crate::group::IsMemberResp =
    deps.querier.query_wasm_smart(my_contract_addr, &msg)?;
```

It is important not to confuse the generated `ContractExecMsg/ContractQueryMsg`
with `ExecMsg/QueryMsg` - the former is generated only for contract, not for interfaces,
and is not meant to use to send messages to the contract - their purpose is for proper
messages dispatching only, and should not be used besides the entry points.

## Query helpers

Syvlia generates `BoundQuerier` and `Remote` helpers to make querying more user-friendly.

```rust
#[derive(sylvia::serde::Serialize, sylvia::serde::Deserialize)]
pub struct Remote<'a>(std::borrow::Cow<'a, sylvia::cw_std::Addr>);

impl Remote<'_> {
    pub fn querier<'a, C: sylvia::cw_std::CustomQuery>(
        &'a self,
        querier: &'a sylvia::cw_std::QuerierWrapper<'a, C>,
    ) -> BoundQuerier<'a, C> {
        BoundQuerier {
            contract: &self.0,
            querier,
        }
    }
}
```

It has a single method implemented called querier which returns the `BoundQuerier` for the stored
address.

```rust

pub struct BoundQuerier<'a, C: sylvia::cw_std::CustomQuery> {
    contract: &'a sylvia::cw_std::Addr,
    querier: &'a sylvia::cw_std::QuerierWrapper<'a, C>,
}

impl<'a, C: sylvia::cw_std::CustomQuery> Querier for BoundQuerier<'a, C> {
    fn counter(&self) -> Result<CounterResp, sylvia::cw_std::StdError> {
        let query = QueryMsg::counter();
        self.querier.query_wasm_smart(self.contract, &query)
    }
}

pub trait Querier {
    fn counter(&self) -> Result<CounterResp, sylvia::cw_std::StdError>;
}
```

For each query method in the contract, `Sylvia` generates a corresponding method in the `Querier` trait for more intuitve querying. This allows for easier and more concise query constructions.

Let's modify the query from the previous paragraph. Currently it will look as follows:

```rust
let is_member = Remote::new(remote_addr)
    .querier(&ctx.deps.querier)
    .is_member(addr)?;
```

Your contract might be implemented such it will be communicating with some other contract regularly.
In such case you might want to store it as a field in your Contract:

```rust
pub struct MyContract<'a> {
    counter: Item<'a, u64>,
    members: Map<'a, &'a Addr, Empty>,
    // Added
    remote: Item<'a, Remote<'static>>,
}

#[msg(exec)]
pub fn evaluate_member(&self, ctx: ExecCtx, ...) -> StdResult<Response> {
    let is_member = self
        .remote
        .load(ctx.deps.storage)?
        .querier(&ctx.deps.querier)
        .is_member(addr)?;
}
```

`Remote` and `BoundQuerier` types are also generated for the interfaces and you can use them too.
Also using the implemented `From` trait you can convert from `contract::BoundQuerier` to
`interface::BoundQuerier`.

```rust
let remote = self.remote.load(ctx.deps.storage)?;
let querier = remote.querier(&ctx.deps.querier);
let other_count = BoundQuerier::from(&querier).count()?.count;
```

## Using Not Implemented Entry Points

While Sylvia covers a wide range of functionality, it may not include all possible CosmWasm entry points. In such cases, traditional entry points can be used. For example:

```rust
use sylvia::cw_std::{DepsMut, Env, Reply, Response};

#[contract]
#[entry_point]
#[error(ContractError)]
#[messages(group as Group)]
impl MyContract<'_> {
    fn reply(&self, deps: DepsMut, env: Env, reply: Reply) -> Result<Response, ContractError> {
        todo!()
    }
    // Some items defined previously
}

#[entry_point]
fn reply(deps: DepsMut, env: Env, reply: Reply) -> Result<Response, ContractError> {
    &MyContract::new().reply(deps, env, reply)
}
```

It is important to create an entry function in the contract type - this way, it gains access to all the state accesors defined on the type.

## Overriding Entry Points in Sylvia

Sometimes, the default setup in Sylvia  might not align with specific requiremtns of your smart contract. This situation can arise if you're aiming to use a `sudo` entry point, but find it unsupported by Sylvia's generated `multi-test helpers`, making it difficult to test your contract effectively. Alternatively, you may have a unique requiremtns necessiating a custom-defined entry point. In such scenerios, Sylvia provides the flexibility to override the default entry point to suit your contract's specific needs.   

Let's consider the following code:

```rust
#[cw_serde]
pub enum UserExecMsg {
    IncreaseByOne {},
}

pub fn increase_by_one(ctx: ExecCtx) -> StdResult<Response> {
    crate::COUNTER.update(ctx.deps.storage, |count| -> Result<u32, StdError> {
        Ok(count + 1)
    })?;
    Ok(Response::new())
}

#[cw_serde]
pub enum CustomExecMsg {
    ContractExec(crate::ContractExecMsg),
    CustomExec(UserExecMsg),
}

impl CustomExecMsg {
    pub fn dispatch(self, ctx: (DepsMut, Env, MessageInfo)) -> StdResult<Response> {
        match self {
            CustomExecMsg::ContractExec(msg) => {
                msg.dispatch(&crate::contract::Contract::new(), ctx)
            }
            CustomExecMsg::CustomExec(_) => increase_by_one(ctx.into()),
        }
    }
}

#[entry_point]
pub fn execute(
    deps: DepsMut,
    env: Env,
    info: MessageInfo,
    msg: CustomExecMsg,
) -> StdResult<Response> {
    msg.dispatch((deps, env, info))
}
```

It is possible to define some custom `exec` message which will dispatch over one generated
by your Contract and one defined by you. To use this custom entry point with `contract` macro
you can add the `sv::override_entry_point(...)` attribute.

```rust    
#[contract]
#[sv::override_entry_point(exec=crate::entry_points::execute(crate::exec::CustomExecMsg))]
#[sv::override_entry_point(sudo=crate::entry_points::sudo(crate::SudoMsg))]
impl Contract {
```

It is possible to override all message types like that. Next to the entry point path you will
also have to provide the type of your custom message. It is required to deserialize the message
in the `multitest helpers`.

## Multitest in Sylvia Framework

Sylvia also generates some helpers for testing contracts - it is hidden behind the
`mt` feature flag, which has to be enabled.

It is important to ensure no `mt` flag is set when the contract is built in `wasm`
target because of some dependencies it uses, which are not buildable on Wasm. My
recommendation is to add an additional `sylvia` entry with `mt` enabled in the
`dev-dependencies`, and also add the `mt` feature on your contract, which enables
mt utilities in other contract tests. An example `Cargo.toml`:

Sylvia enhances your smart contract testing experince by providing specialized testing utilities, conveniently accesible under the `mt`(multi-test) feature flag. This feature is instrumental in creating a robus and reliable testing enviroment for your contracts.

### Setting Up the Multi-test feature

To leverage Sylvia's multi-test capabilities, you must enable the `mt` feature. However, it's crucial to note that this feature should not be active when building your contract for the Wasm target. This precaution is due to certain dependencies in the `mt` feature that are incompatible with Wasm builds. To circumvent this, it's recommended to include Sulvia with the `mt` feature enabled in your `dev-depencies`. This setup allows you to utilize the multi-test utilities in your contract tests without affecting the Wasm build.

Here's an example `Cargo.toml` configuration demonstrating how to set this up:

```rust
[package]
name = "my-contract"
version = "0.1.0"
edition = "2021"

[lib]
crate-type = ["cdylib", "rlib"]

[features]
library = []
mt = ["sylvia/mt"]

[dependencies]
cosmwasm-schema = "1.2.5"
cosmwasm-std = "1.2.5"
cw-storage-plus = "1.0.1"
schemars = "0.8.12"
serde = "1.0.160"
sylvia = "0.5.0"
thiserror = "1.0.40"

[dev-dependencies]
sylvia = { path = "0.5.0", features = ["mt"] }
```

There would obviously be more dependencies - most probably `cw-storage-plus`,
but this is just to show how I enable the `mt` flag. With that, we can use mt
utils in the contract:

```rust
#[cfg(test)]
mod tests {
    use super::*;
    use sylvia::multitest::App;

    #[test]
    fn counter_test() {
        let app = App::default();

        let owner = "owner";

        let code_id = contract::CodeId::store_code(&app);

        let contract = code_id.instantiate(3)
            .with_label("My contract")
            .call(owner)
            .unwrap();

        let counter = contract.counter().unwrap();
        assert_eq!(counter, contract::CounterResp { counter: 3});

        contract.increment().call(owner).unwrap();

        let counter = contract.counter().unwrap();
        assert_eq!(counter, contract::CounterResp { counter: 4});
    }
}
```

First of all, note the `contract` module I am using here - it is a slight change
that doesn't match the previous code - I assume here that all the contract code
sits in the `contract` module to make sure it is clear where the used type lies.
So if I use `contract::something`, it is `something` in the module of the original
contract (most probably sylvia-generated).

First of all - we do not use `cw-multi-test` app directly. Instead we use the `sylvia`
wrapper over it. It contains the original multi-test App internally, but it does
it in an internally-mutable manner which makes it possible to avoid passing it
everywhere around. It adds some overhead, but it should not matter for testing code.

We are first using the `CodeId` type generated for every single Sylvia contract
separately. Its purpose is to abstract storing the contract in the blockchain. It
makes sure to create the contract object and pass it to the multitest.

A contract's `CodeId` type has one particularly interesting function - the `instantiate`,
which calls an instantiation function. It takes the same arguments as an instantiation
function in the contract, except for the context that Sylvia's utilities would provide.

The function doesn't instantiate contract immediately - instead, it returns what
is called `InstantiationProxy`. We decided that we don't want to force users to set
all the metadata - admin, label, and funds to send with every instantiation call,
as in the vast majority of cases, they are irrelevant. Instead, the
`InstantiationProxy` provides `with_label`, `with_funds`, and `with_amin` functions,
which set those meta fields in the builder pattern style.

When the instantiation is ready, we call the `call` function, passing the message
sender - we could add another `with_sender` function, but we decided that as the
sender has to be passed every single time, we can save some keystrokes on that.

The thing is similar when it comes to execution messages. The biggest difference
is that we don't call it on the `CodeId`, but on instantiated contracts instead.
We also have fewer fields to set on that - the proxy for execution provides only
the `with_funds` function.

All the instantiation and execution functions return the
`Result<cw_multi_test::AppResponse, ContractError>` type, where `ContractError`
is an error type of the contract.

## Interface items in multitest

Sylvia's approach to multi-testing interfaces in contract's introduces some nuances, particularly when calling methods from a contract's interface. Due to implementation constraints, the process of invoking interface methods in a multitest environment slightly differs from the standard procedure.

### Implementing Interface Methods in Multi-test

In multi-test, when you need to call methods from your contract's interace, Sylvia requires, the use case of a proxy wrapper. This wrapper, unique to the multitest setup ensure that mesesages are correctly routed the specific interface they belong to.

### Example: Testing Interface Methods

Consider the following example where we test methods from a `Group` interface:

```rust
use contract::multitest_utils::Group;

#[test]
fn member_test() {
    let app = App::default();

    let owner = "owner";
    let member = "john";

    let code_id = contract::multitest_utils::CodeId::store_code(&app);

    let contract = code_id.instantiate(0)
        .with_label("My contract")
        .call(owner);

    contract
        .group_proxy()
        .add_member(member.to_owned())
        .call(owner);

    let resp = contract
        .group_proxy()
        .is_member(member.to_owned())

    assert_eq!(resp, group::IsMemberResp { is_member: true });
}
```

### Key Points in this Example

- **Initialization of Multitest App:** We start by creating an instance of App, setting the stage for our test environment.
- **Storing and Instantiating the Contract:** The contract is stored and instantiated using CodeId from Sylvia's multitest utilities. This process abstracts away some of the complexities involved in deploying and initializing smart contracts in a testing context.
- **Using the group_proxy() Method:** The `group_proxy()` function call is crucial. It returns a proxy wrapper specifically for the Group interface, allowing us to call the interface's methods (`add_member` and `is_member`) in the multitest context.
- **Asserting Test Results:** Finally, we assert the expected outcome of our interface method calls, ensuring that the contract's logic functions as intended.

### The Role of the Proxy Wrapper

The proxy wrapper `(group_proxy())`  plays a vital role in this setup. It acts as a bridge between the test environment and the contract's interface, ensuring that the messages are accurately dispatched to the appropriate interface methods. This added layer is essential due to the unique way Sylvia handles message dispatching in a multitest environment.

### Adding Traits for Group Related Methods

- **Initialization of Multitest App:** We start by creating an instance of App, setting the stage for our test environment.
- **Storing and Instantiating the Contract:** The contract is stored and instantiated using CodeId from Sylvia's multitest utilities. This process abstracts away some of the complexities involved in deploying and initializing smart contracts in a testing context.
- **Using the group_proxy() Method:** The `group_proxy()` function call is crucial. It returns a proxy wrapper specifically for the Group interface, allowing us to call the interface's methods (`add_member` and `is_member`) in the multitest context.
- **Asserting Test Results:** Finally, we assert the expected outcome of our interface method calls, ensuring that the contract's logic functions as intended.
- **Adding Traits for Group-Related Methods:** To facilitate this process, a trait corresponding to the interface (in this case, Group) is added to the multitest_utils module of the contract. This trait mirrors the original Group trait but is specifically tailored for the multitest environment, accommodating the nuances of message dispatching and handling within this context.

## CustomQuery and CustomMsg in Sylvia Interfaces
Sylvia's framework enhances smart contract development by allowing interfaces to work with `CustomQuery` and `CustomMsg`. This capability is crucial for creating interfaces that are tailored to specific communication needs within a contract.

### Defining Custom Messages
You can define custom messages by implementing `CustomMsg` and `CustomQuery`. These custom types enable specialized communication within your contractâ€™s ecosystem.

```rust
struct MyMsg;
impl CustomMsg for MyMsg {}

struct MyQuery;
impl CustomQuery for MyMsg {}
```
### Using `sv::custom` for Specific Message Types

The `sv::custom` attribute in Sylvia.

Facilitates a direct association between interfaces and specific custom message types. 
This association is pivotal for ensuring that the interface interacts only with the intended types of messages.


```rust
#[interface]
#[sv::custom(query=MyQuery, msg=MyMsg)]
pub trait SomeInterface {
}

#[contract(module=super)]
#[sv::custom(msg=MyMsg, query=MyQuery)]
impl SomeInterface for crate::MyContract {
}
```

### Flexibility with Associated Types

Sylvia also provides the option to define interfaces with associated types for execution and query messages. This approach grants greater flexibility, allowing contract developers to specify which message types their interface should use.

With interface defined as such:

```rust
#[interface]
pub trait AssociatedInterface {
    type Error: From<StdError>;
    type ExecC: CustomMsg;
    type QueryC: CustomQuery;
}

#[contract(module=super)]
#[sv::custom(msg=MyMsg)]
impl AssociatedInterface for crate::MyContract {
    type Error = StdError;
    type ExecC = MyMsg;
    type QueryC = MyQuery;

    #[msg(exec)]
    fn associated_exec(&self, _ctx: ExecCtx<Self::QueryC>) -> StdResult<Response<Self::ExecC>> {
        Ok(Response::default())
    }
}
```

In this approach, `AssociatedInterface` permits the implementer to define their custom message types, offering a versatile framework for contract messaging.

### Prioritizing sv::custom
When both associated types and the `sv::custom()` attribute are present, Sylvia prioritizes the `sv::custom()` attribute. This prioritization is key to maintaining a clear and consistent approach to handling custom messages within the interface.


## Generics in Sylvia Framework

With the release of version `0.9.0`, `sylvia` introduced the capability to use generics alongside its macros. This enhancement marks a significant step forward in the framework, offering greater flexibility and power in contract and interface design.

### Generics with Sylvia Macros
The integration of generics into `sylvia's` macros allows developers to define contracts and interfaces that are not just powerful but also versatile. This feature caters to a wide range of scenarios where generic types can simplify complex contract logic or enable more dynamic interface designs.

### Generic interface

Similarly, you can define generic interfaces in Sylvia. This feature allows for the creation of interfaces that are adaptable to various types, thereby broadening the scope and utility of the interface within the smart contract ecosystem.

```rust
#[interface]
pub trait Generic<ExecParam, QueryParam, RetType>
where
    for<'msg_de> ExecParam: CustomMsg + Deserialize<'msg_de>,
    QueryParam: sylvia::types::CustomMsg,
    RetType: CustomMsg + DeserializeOwned,
{
    type Error: From<StdError>;

    #[msg(exec)]
    fn generic_exec(
        &self,
        ctx: ExecCtx,
        msgs: Vec<CosmosMsg<ExecParam>>,
    ) -> Result<Response, Self::Error>;

    #[msg(query)]
    fn generic_query(&self, ctx: QueryCtx, param: QueryParam) -> Result<RetType, Self::Error>;
}
```

We can also use generics with `custom`. In such case we have to provide the generic
type name to the `sv::custom(..)` attribute.

```rust
#[interface]
#[sv::custom(msg=RetType)]
pub trait CustomAndGeneric<ExecParam, QueryParam, RetType>
where
    for<'msg_de> ExecParam: CustomMsg + Deserialize<'msg_de>,
    QueryParam: sylvia::types::CustomMsg,
    RetType: CustomMsg + DeserializeOwned,
{
    type Error: From<StdError>;

    #[msg(exec)]
    fn custom_generic_execute(
        &self,
        ctx: ExecCtx,
        msgs: Vec<CosmosMsg<ExecParam>>,
    ) -> Result<Response<RetType>, Self::Error>;

    #[msg(query)]
    fn custom_generic_query(
       &self,
        ctx: QueryCtx,
        param: QueryParam,
    ) -> Result<RetType, Self::Error>;
}
```

### Generic contract

Defining a generic contract in Sylvia means that you can create a contract template with type parameters. This template can then be instantiated with different types, allowing for code reuse and modular design.

```rust
pub struct GenericContract<
    InstantiateParam,
    ExecParam,
    FieldType,
> {
    _field: Item<'static, FieldType>,
    _phantom: std::marker::PhantomData<(
        InstantiateParam,
        ExecParam,
    )>,
}

#[contract]
impl<InstantiateParam, ExecParam, FieldType>
    GenericContract<InstantiateParam, ExecParam, FieldType>
where
    for<'msg_de> InstantiateParam: CustomMsg + Deserialize<'msg_de> + 'msg_de,
    ExecParam: CustomMsg + DeserializeOwned + 'static,
    FieldType: 'static,
{
    pub const fn new() -> Self {
        Self {
            _field: Item::new("field"),
            _phantom: std::marker::PhantomData,
        }
    }

    #[msg(instantiate)]
    pub fn instantiate(
        &self,
        _ctx: InstantiateCtx,
        _msg: InstantiateParam,
    ) -> StdResult<Response> {
        Ok(Response::new())
    }

    #[msg(exec)]
    pub fn contract_execute(
        &self,
        _ctx: ExecCtx,
        _msg: ExecParam,
    ) -> StdResult<Response> {
        Ok(Response::new())
    }
}
```
In this example, the contract is defined with generic parameters, enabling it to be flexible and reusable across different contexts. This approach significantly reduces code duplication and enhances the overall maintainability of the contract code.

### Implementing a Generic Interface in Sylvia

Sylvia's framework not only supports the creation of generic contracts and interfaces but also provides a streamlined way to implement these interfaces. When working with generic interfaces, the implementation process involves providing concrete types for the generic parameters.

### Process of Implementing a Generic Interface

To implement a generic interface in Sylvia, you need to specify the actual types for the generic parameters defined in the interface. This step is crucial as it determines how the interface will interact with the rest of your contract.

Consider the following example where a generic interface is implemented with specific types:

```rust
#[contract(module = crate::contract)]
#[messages(generic as Generic)]
#[sv::custom(msg=SvCustomMsg)]
impl<InstantiateParam, ExecParam, FieldType>
    Generic<SvCustomMsg, SvCustomMsg, sylvia::types::SvCustomMsg>
    for crate::contract::GenericContract<
        InstantiateParam,
        ExecParam,
        FieldType,
    >
{
    type Error = StdError;

    #[msg(exec)]
    fn generic_exec(
        &self,
        _ctx: ExecCtx,
        _msgs: Vec<CosmosMsg<sylvia::types::SvCustomMsg>>,
    ) -> StdResult<Response> {
        Ok(Response::new())
    }

    #[msg(query)]
    fn generic_query(
        &self,
        _ctx: QueryCtx,
        _msg: sylvia::types::SvCustomMsg,
    ) -> StdResult<SvCustomMsg> {
        Ok(SvCustomMsg {})
    }
}
```

Then we have to inform `sylvia` about the generics used while implementing 
interface in the main `contract` macro call:

```rust
#[contract]
#[messages(generic<SvCustomMsg, SvCustomMsg, sylvia::types::SvCustomMsg> as Generic)]
impl<InstantiateParam, ExecParam, FieldType>
    GenericContract<InstantiateParam, ExecParam, FieldType>
where
    for<'msg_de> InstantiateParam: CustomMsg + Deserialize<'msg_de> + 'msg_de,
    ExecParam: CustomMsg + DeserializeOwned + 'static,
    FieldType: 'static,
{
}
```

### Generics in Entry Points with Sylvia

In Sylvia, when dealing with generic contracts, entry points play a crucial role and must be defined with specific, solid types. 

This requirement ensures that the entry points are properly generated and aligned with the contract's generic structure.

### Specific Types in Entry Points

When using the `entry_points` macro in a generic contract, you must explicitly specify the types to be used. 

This is crucial for the correct generation of entry points that are compatible with the generic nature of the contract. We do that by via `entry_points(generics<..>)`:


```rust
#[cfg_attr(not(feature = "library"), entry_points(generics<SvCustomMsg, SvCustomMsg, SvCustomMsg>))]
#[contract]
impl<InstantiateParam, ExecParam, FieldType>
    GenericContract<InstantiateParam, ExecParam, FieldType>
where
    for<'msg_de> InstantiateParam: CustomMsg + Deserialize<'msg_de> + 'msg_de,
    ExecParam: CustomMsg + DeserializeOwned + 'static,
    FieldType: 'static,
{
    ...
}
```

## Generating schema

Sylvia simplifies the process of generating a schema for your contract by automating the code generation required by `cosmwasm-schema`. This automation makes it straightforward to create a schema, which is essential for contract interaction and documentation.

```rust
use cosmwasm_schema::write_api;

use my_contract_crate::contract::{ContractExecMsg, ContractQueryMsg, InstantiateMsg};

fn main() {
    write_api! {
        instantiate: InstantiateMsg,
        execute: ContractExecMsg,
        query: ContractQueryMsg,
    }
}
```

## Road map

Sylvia is in the adoption stage right now, but we are still working on more and more
features for you. Here is a rough roadmap for the incoming months:

- Sudo support - Although you can define your own sudo entry point it is currently
  not supported in generated multitest helpers.
- Replies - Sylvia still needs support for essential CosmWasm messages, which are
  replies. We want to make them smart, so expressing the correlation between send
  message end executed handler is more direct and not hidden in the reply dispatcher.
- Migrations - Another important message we don't support, but the reason is similar
  to replies - we want them to be smart. We want to give you a nice way to provide
  upgrading Api for your contract, which would take care of its versioning.
- IBC - we want to give you a nice IBC Api too! However, expect it to be a
  while - we must first understand the best patterns here.
- Better tooling support - The biggest issue of Sylvia is that code it generates
  is not trivial, and not all the tooling handles it well. We are working on improving
  user experience in that regard.

## Troubleshooting

For more descriptive error messages, consider using the nightly toolchain (add `+nightly`
argument for cargo)

- Missing messages from interface on your contract - You may be missing
  `messages(interface as Interface)` attribute.
- Cannot find type BoundQuerier - your `Contract` is defined in different module than current one.
  Your `impl Interface for Contract` should have the `#[contract(module=path::to::Contract)]`
  invocation.
